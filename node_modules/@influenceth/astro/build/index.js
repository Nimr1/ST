function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
import * as math from 'mathjs';
import * as cephes from 'cephes';
var modulo = function modulo(x, y) {
  return (x % y + y) % y;
};
var rotation_matrix = function rotation_matrix(angle, axis) {
  var c = Math.cos(angle);
  var s = Math.sin(angle);
  var a1 = modulo(axis + 1, 3);
  var a2 = modulo(axis + 2, 3);
  var R = math.zeros([3, 3]);
  R[axis][axis] = 1;
  R[a1][a1] = c;
  R[a1][a2] = -s;
  R[a2][a1] = s;
  R[a2][a2] = c;
  return R;
};
var E_to_M = function E_to_M(E, ecc) {
  return E - ecc * Math.sin(E);
};
var M_to_E = function M_to_E(M, ecc) {
  var E1, fVal, fDer, step;
  var E = M < 0 ? M - ecc : M + ecc;
  for (var i = 0; i < 50; i++) {
    fVal = E_to_M(E, ecc) - M;
    fDer = 1 - ecc * Math.cos(E);
    step = fVal / fDer;
    E1 = E - step;
    if (Math.abs(E1 - E) < 1e-7) {
      break;
    } else {
      E = E1;
    }
  }
  return E1;
};
var E_to_nu = function E_to_nu(E, ecc) {
  return 2 * Math.atan(Math.sqrt((1 + ecc) / (1 - ecc)) * Math.tan(E / 2));
};
var nu_to_E = function nu_to_E(nu, ecc) {
  return 2 * Math.atan(Math.sqrt((1 - ecc) / (1 + ecc)) * Math.tan(nu / 2));
};
var F_to_M = function F_to_M(F, ecc) {
  return ecc * Math.sinh(F) - F;
};
var M_to_F = function M_to_F(M, ecc) {
  var F1, fVal, fDer, step;
  var F = Math.asinh(M / ecc);
  for (var i = 0; i < 50; i++) {
    fVal = F_to_M(F, ecc) - M;
    fDer = ecc * Math.cosh(F) - 1;
    step = fVal / fDer;
    F1 = F - step;
    if (Math.abs(F1 - F) < 1e-7) {
      break;
    } else {
      F = F1;
    }
  }
  return F;
};
var F_to_nu = function F_to_nu(F, ecc) {
  return 2 * Math.atan(Math.sqrt((ecc + 1) / (ecc - 1)) * Math.tanh(F / 2));
};
var nu_to_F = function nu_to_F(nu, ecc) {
  return 2 * Math.atanh(Math.sqrt((ecc - 1) / (ecc + 1)) * Math.tan(nu / 2));
};
var M_to_nu = function M_to_nu(M, ecc) {
  var delta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e-2;
  if (ecc < 1 - delta) {
    M = modulo(M + Math.PI, 2 * Math.PI) - Math.PI;
    return E_to_nu(M_to_E(M, ecc), ecc);
  } else if (ecc < 1) {
    return D_to_nu(M_to_D_near_parabolic(M, ecc));
  } else if (ecc == 1) {
    return D_to_nu(M_to_D(M));
  } else if (ecc < 1 + delta) {
    return D_to_nu(M_to_D_near_parabolic(M, ecc));
  } else {
    return F_to_nu(M_to_F(M, ecc), ecc);
  }
};
var nu_to_M = function nu_to_M(nu, ecc) {
  var delta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e-2;
  if (ecc < 1 - delta) {
    return E_to_M(nu_to_E(nu, ecc), ecc);
  } else if (ecc < 1) {
    return D_to_M_near_parabolic(nu_to_D(nu), ecc);
  } else if (ecc == 1) {
    return D_to_M(nu_to_D(nu));
  } else if (ecc < 1 + delta) {
    return D_to_M_near_parabolic(nu_to_D(nu), ecc);
  } else {
    return F_to_M(nu_to_F(nu, ecc), ecc);
  }
};
var D_to_M = function D_to_M(D) {
  return D + Math.pow(D, 3) / 3;
};
var D_to_M_near_parabolic = function D_to_M_near_parabolic(D, ecc) {
  var x = (ecc - 1) / (ecc + 1) * Math.pow(D, 2);
  if (Math.abs(x) >= 1) throw new Error('abs(x) must be less than 1');
  var S = _S_x(ecc, x);
  return Math.sqrt(2 / (1 + ecc)) * D + Math.sqrt(2 / Math.pow(1 + ecc, 3)) * Math.pow(D, 3) * S;
};
var M_to_D_near_parabolic = function M_to_D_near_parabolic(M, ecc) {
  var D1, fVal, fDer, step;
  var D = M_to_D(M);
  for (var i = 0; i < 50; i++) {
    fVal = D_to_M_near_parabolic(D, ecc) - M;
    fDer = _kepler_equation_prime_near_parabolic(D, ecc);
    step = fVal / fDer;
    D1 = D - step;
    if (Math.abs(D1 - D) < 1.48e-8) {
      break;
    } else {
      D = D1;
    }
  }
  return D;
};
var M_to_D = function M_to_D(M) {
  var B = 3 * M / 2;
  var A = Math.pow(B + Math.pow(1 + Math.pow(B, 2), 0.5), 2 / 3);
  return 2 * A * B / (1 + A + Math.pow(A, 2));
};
var D_to_nu = function D_to_nu(D) {
  return 2 * Math.atan(D);
};
var nu_to_D = function nu_to_D(nu) {
  return Math.tan(nu / 2);
};
var _kepler_equation_prime_near_parabolic = function _kepler_equation_prime_near_parabolic(D, ecc) {
  var x = (ecc - 1) / (ecc + 1) * Math.pow(D, 2);
  if (Math.abs(x) >= 1) throw new Error('abs(x) must be less than 1');
  var S = _dS_x_alt(ecc, x);
  return Math.sqrt(2 / (1 + ecc)) + Math.sqrt(2 / Math.pow(1 + ecc, 3)) * Math.pow(D, 2) * S;
};
var _S_x = function _S_x(ecc, x) {
  var atol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e-12;
  if (Math.abs(x) >= 1) throw new Error('abs(x) must be less than 1');
  var S = 0;
  var k = 0;
  while (true) {
    var S_old = S;
    S += (ecc - 1 / (2 * k + 3)) * Math.pow(x, k);
    k += 1;
    if (Math.abs(S - S_old) < atol) return S;
  }
};
var _dS_x_alt = function _dS_x_alt(ecc, x) {
  var atol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e-12;
  if (Math.abs(x) >= 1) throw new Error('abs(x) must be less than 1');
  var S = 0;
  var k = 0;
  while (true) {
    var S_old = S;
    S += (ecc - 1 / (2 * k + 3)) * (2 * k + 3) * Math.pow(x, k);
    k += 1;
    if (Math.abs(S - S_old) < atol) return S;
  }
};
var angles = {
  E_to_M: E_to_M,
  M_to_E: M_to_E,
  E_to_nu: E_to_nu,
  nu_to_E: nu_to_E,
  F_to_M: F_to_M,
  M_to_F: M_to_F,
  F_to_nu: F_to_nu,
  nu_to_F: nu_to_F,
  M_to_nu: M_to_nu,
  nu_to_M: nu_to_M,
  D_to_M: D_to_M,
  M_to_D: M_to_D,
  D_to_nu: D_to_nu,
  nu_to_D: nu_to_D,
  M_to_D_near_parabolic: M_to_D_near_parabolic,
  D_to_M_near_parabolic: D_to_M_near_parabolic
};
var G = 6.67430E-11;
var AU = 1.495978707e11;
var constants = {
  G: G,
  AU: AU
};
var coe2rv = function coe2rv(mu, p, ecc, inc, raan, argp, nu) {
  var pqw = math.dotMultiply([[Math.cos(nu), Math.sin(nu), 0], [-Math.sin(nu), ecc + Math.cos(nu), 0]], [[0, 0, 0].fill(p / (1 + ecc * Math.cos(nu)), 0, 3), [0, 0, 0].fill(Math.sqrt(mu / p), 0, 3)]);
  var rm = rotation_matrix(raan, 2);
  rm = math.multiply(rm, rotation_matrix(inc, 0));
  rm = math.multiply(rm, rotation_matrix(argp, 2));
  return math.multiply(pqw, math.transpose(rm));
};
var rv2coe = function rv2coe(mu, r, v) {
  var tol = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-8;
  var raan, argp, nu;
  var h = math.cross(r, v);
  var n = math.cross([0, 0, 1], h);
  var e = math.divide(math.subtract(math.multiply(math.dot(v, v) - mu / math.norm(r), r), math.multiply(math.dot(r, v), v)), mu);
  var ecc = math.norm(e);
  var p = math.dot(h, h) / mu;
  var inc = Math.acos(h[2] / math.norm(h));
  var circular = ecc < tol;
  var equatorial = Math.abs(inc) < tol;
  if (equatorial && !circular) {
    raan = 0;
    argp = Math.atan2(e[1], e[0]) % (2 * Math.PI);
    nu = Math.atan2(math.dot(h, math.cross(e, r)) / math.norm(h), math.dot(r, e));
  } else if (!equatorial && circular) {
    raan = modulo(Math.atan2(n[1], n[0]), 2 * Math.PI);
    argp = 0;
    nu = Math.atan2(math.dot(r, math.cross(h, n)) / math.norm(h), math.dot(r, n));
  } else if (equatorial && circular) {
    raan = 0;
    argp = 0;
    nu = modulo(Math.atan2(r[1], r[0]), 2 * Math.PI);
  } else {
    var a = p / (1 - Math.pow(ecc, 2));
    var mu_a = mu * a;
    if (a > 0) {
      var e_se = math.dot(r, v) / Math.sqrt(mu_a);
      var e_ce = math.norm(r) * math.dot(v, v) / mu - 1;
      var E = Math.atan2(e_se, e_ce);
      nu = E_to_nu(E, ecc);
    } else {
      var e_sh = math.dot(r, v) / Math.sqrt(-mu_a);
      var e_ch = math.norm(r) * Math.pow(math.norm(v), 2) / mu - 1;
      var F = Math.log((e_ch + e_sh) / (e_ch - e_sh)) / 2;
      nu = F_to_nu(F, ecc);
    }
    raan = modulo(Math.atan2(n[1], n[0]), 2 * Math.PI);
    var px = math.dot(r, n);
    var py = math.dot(r, math.cross(h, n)) / math.norm(h);
    argp = modulo(Math.atan2(py, px) - nu, 2 * Math.PI);
  }
  nu = (nu % (2 * Math.PI) + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
  return {
    p: p,
    ecc: ecc,
    inc: inc,
    raan: raan,
    argp: argp,
    nu: nu
  };
};
var elements = {
  coe2rv: coe2rv,
  rv2coe: rv2coe
};
var solver = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(mu, r1, r2, tof) {
    var M,
      prograde,
      low_path,
      maxiter,
      atol,
      rtol,
      c,
      c_norm,
      r1_norm,
      r2_norm,
      s,
      i_r1,
      i_r2,
      i_h,
      ll,
      i_t1,
      i_t2,
      T,
      _findXY2,
      _findXY3,
      x,
      y,
      gamma,
      rho,
      sigma,
      _reconstruct2,
      _reconstruct3,
      V_r1,
      V_r2,
      V_t1,
      V_t2,
      v1,
      v2,
      _args = arguments;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          M = _args.length > 4 && _args[4] !== undefined ? _args[4] : 0;
          prograde = _args.length > 5 && _args[5] !== undefined ? _args[5] : true;
          low_path = _args.length > 6 && _args[6] !== undefined ? _args[6] : true;
          maxiter = _args.length > 7 && _args[7] !== undefined ? _args[7] : 35;
          atol = _args.length > 8 && _args[8] !== undefined ? _args[8] : 1e-5;
          rtol = _args.length > 9 && _args[9] !== undefined ? _args[9] : 1e-7;
          _context.next = 8;
          return cephes.compiled;
        case 8:
          validateGravitationalParam(mu);
          validatePositions(r1, r2);
          c = math.subtract(r2, r1);
          c_norm = math.norm(c);
          r1_norm = math.norm(r1);
          r2_norm = math.norm(r2);
          s = math.multiply(math.add(r1_norm, r2_norm, c_norm), 0.5);
          i_r1 = math.divide(r1, r1_norm);
          i_r2 = math.divide(r2, r2_norm);
          i_h = math.cross(i_r1, i_r2);
          i_h = math.divide(i_h, math.norm(i_h));
          ll = Math.sqrt(1 - Math.min(1.0, c_norm / s));
          if (i_h[2] < 0) {
            ll = -ll;
            i_t1 = math.cross(i_r1, i_h);
            i_t2 = math.cross(i_r2, i_h);
          } else {
            i_t1 = math.cross(i_h, i_r1);
            i_t2 = math.cross(i_h, i_r2);
          }
          if (!prograde) {
            ll = -ll;
            i_t1 = math.multiply(-1, i_t1);
            i_t2 = math.multiply(-1, i_t2);
          }
          T = Math.sqrt(2 * mu / Math.pow(s, 3)) * tof;
          _findXY2 = _findXY(ll, T, M, maxiter, atol, rtol, low_path), _findXY3 = _slicedToArray(_findXY2, 2), x = _findXY3[0], y = _findXY3[1];
          gamma = Math.sqrt(mu * s / 2);
          rho = (r1_norm - r2_norm) / c_norm;
          sigma = Math.sqrt(1 - Math.pow(rho, 2));
          _reconstruct2 = _reconstruct(x, y, r1_norm, r2_norm, ll, gamma, rho, sigma), _reconstruct3 = _slicedToArray(_reconstruct2, 4), V_r1 = _reconstruct3[0], V_r2 = _reconstruct3[1], V_t1 = _reconstruct3[2], V_t2 = _reconstruct3[3];
          v1 = math.add(math.multiply(V_r1, math.divide(r1, r1_norm)), math.multiply(V_t1, i_t1));
          v2 = math.add(math.multiply(V_r2, math.divide(r2, r2_norm)), math.multiply(V_t2, i_t2));
          return _context.abrupt("return", [v1, v2]);
        case 31:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function solver(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();
var validateGravitationalParam = function validateGravitationalParam(mu) {
  if (mu <= 0) throw new Error('Gravitational parameter must be positive');
};
var validatePositions = function validatePositions(r1, r2) {
  validatePosition(r1);
  validatePosition(r2);
  if (r1.filter(function (e) {
    return r2.includes(e);
  }).length === 3) throw new Error('Initial and final positions can not be the same');
};
var validatePosition = function validatePosition(r) {
  if (r.length !== 3) throw new Error('Position vector must be three dimensional');
  if (r.find(function (e) {
    return e !== 0;
  }) === undefined) throw new Error('Position can not be at origin');
};
var _reconstruct = function _reconstruct(x, y, r1, r2, ll, gamma, rho, sigma) {
  var V_r1 = gamma * (ll * y - x - rho * (ll * y + x)) / r1;
  var V_r2 = -gamma * (ll * y - x + rho * (ll * y + x)) / r2;
  var V_t1 = gamma * sigma * (y + ll * x) / r1;
  var V_t2 = gamma * sigma * (y + ll * x) / r2;
  return [V_r1, V_r2, V_t1, V_t2];
};
var _findXY = function _findXY(ll, T, M, maxiter, atol, rtol, low_path) {
  if (Math.abs(ll) >= 1) throw new Error('Derivative is not continuous');
  var M_max = Math.floor(T / Math.PI);
  var T_00 = Math.acos(ll) + ll * Math.sqrt(1 - Math.pow(ll, 2));
  if (T < T_00 + M_max * Math.PI && M_max > 0) {
    var T_min = _computeTMin(ll, M_max, maxiter, atol, rtol);
    if (T < T_min) M_max -= 1;
  }
  if (M > M_max) throw new Error('No feasible solution, try lower M!');
  var x_0 = _initialGuess(T, ll, M, low_path);
  var x = _householder(x_0, T, ll, M, atol, rtol, maxiter);
  var y = _computeY(x, ll);
  return [x, y];
};
var _computeY = function _computeY(x, ll) {
  return Math.sqrt(1 - Math.pow(ll, 2) * (1 - Math.pow(x, 2)));
};
var _computePsi = function _computePsi(x, y, ll) {
  if (-1 <= x && x < 1) {
    return Math.acos(x * y + ll * (1 - Math.pow(x, 2)));
  } else if (x > 1) {
    return Math.asinh((y - x * ll) * Math.sqrt(Math.pow(x, 2) - 1));
  } else {
    return 0.0;
  }
};
var _tofEquation = function _tofEquation(x, T0, ll, M) {
  return _tofEquationY(x, _computeY(x, ll), T0, ll, M);
};
var _tofEquationY = function _tofEquationY(x, y, T0, ll, M) {
  var T_;
  if (M == 0 && Math.sqrt(0.6) < x && x < Math.sqrt(1.4)) {
    var eta = y - ll * x;
    var S_1 = (1 - ll - x * eta) * 0.5;
    var Q = 4 / 3 * cephes.hyp2f1(3, 1, 5 / 2, S_1);
    T_ = (Math.pow(eta, 3) * Q + 4 * ll * eta) * 0.5;
  } else {
    var psi = _computePsi(x, y, ll);
    T_ = math.divide(math.divide(psi + M * Math.PI, Math.sqrt(Math.abs(1 - Math.pow(x, 2)))) - x + ll * y, 1 - Math.pow(x, 2));
  }
  return T_ - T0;
};
var _tofEquationP = function _tofEquationP(x, y, T, ll) {
  return (3 * T * x - 2 + 2 * Math.pow(ll, 3) * x / y) / (1 - Math.pow(x, 2));
};
var _tofEquationP2 = function _tofEquationP2(x, y, T, dT, ll) {
  return (3 * T + 5 * x * dT + 2 * (1 - Math.pow(ll, 2)) * Math.pow(ll, 3) / Math.pow(y, 3)) / (1 - Math.pow(x, 2));
};
var _tofEquationP3 = function _tofEquationP3(x, y, _, dT, ddT, ll) {
  return (7 * x * ddT + 8 * dT - 6 * (1 - Math.pow(ll, 2)) * Math.pow(ll, 5) * x / Math.pow(y, 5)) / (1 - Math.pow(x, 2));
};
var _computeTMin = function _computeTMin(ll, M, maxiter, atol, rtol) {
  var x_T_min, T_min;
  if (ll === 1) {
    x_T_min = 0.0;
    T_min = _tofEquation(x_T_min, 0.0, ll, M);
  } else {
    if (M === 0) {
      x_T_min = Infinity;
      T_min = 0.0;
    } else {
      var x_i = 0.1;
      var T_i = _tofEquation(x_i, 0.0, ll, M);
      x_T_min = _halley(x_i, T_i, ll, atol, rtol, maxiter);
      T_min = _tofEquation(x_T_min, 0.0, ll, M);
    }
  }
  return T_min;
};
var _initialGuess = function _initialGuess(T, ll, M, low_path) {
  var x_0;
  if (M === 0) {
    var T_0 = Math.acos(ll) + ll * Math.sqrt(1 - Math.pow(ll, 2)) + M * Math.PI;
    var T_1 = 2 * (1 - Math.pow(ll, 3)) / 3;
    if (T >= T_0) {
      x_0 = Math.pow(T_0 / T, 2 / 3) - 1;
    } else if (T < T_1) {
      x_0 = 5 / 2 * T_1 / T * (T_1 - T) / (1 - Math.pow(ll, 5)) + 1;
    } else {
      x_0 = Math.pow(T_0 / T, Math.log2(T_1 / T_0)) - 1;
    }
    return x_0;
  } else {
    var x_0l = (Math.pow((M * Math.PI + Math.PI) / (8 * T), 2 / 3) - 1) / (Math.pow((M * Math.PI + Math.PI) / (8 * T), 2 / 3) + 1);
    var x_0r = (Math.pow(8 * T / (M * Math.PI), 2 / 3) - 1) / (Math.pow(8 * T / (M * Math.PI), 2 / 3) + 1);
    x_0 = low_path ? Math.max(x_0l, x_0r) : Math.min(x_0l, x_0r);
    return x_0;
  }
};
var _halley = function _halley(p0, T0, ll, atol, rtol, maxiter) {
  for (var ii = 1; ii <= maxiter; ii++) {
    var y = _computeY(p0, ll);
    var fder = _tofEquationP(p0, y, T0, ll);
    var fder2 = _tofEquationP2(p0, y, T0, fder, ll);
    if (fder2 === 0) throw new Error('Derivative was zero');
    var fder3 = _tofEquationP3(p0, y, T0, fder, fder2, ll);
    var p = p0 - 2 * fder * fder2 / (2 * Math.pow(fder2, 2) - fder * fder3);
    if (Math.abs(p - p0) < rtol * Math.abs(p0) + atol) return p;
    p0 = p;
  }
  throw new Error('Failed to converge');
};
var _householder = function _householder(p0, T0, ll, M, atol, rtol, maxiter) {
  for (var ii = 1; ii <= maxiter; ii++) {
    var y = _computeY(p0, ll);
    var fval = _tofEquationY(p0, y, T0, ll, M);
    var T = fval + T0;
    var fder = _tofEquationP(p0, y, T, ll);
    var fder2 = _tofEquationP2(p0, y, T, fder, ll);
    var fder3 = _tofEquationP3(p0, y, T, fder, fder2, ll);
    var p = p0 - fval * ((Math.pow(fder, 2) - fval * fder2 / 2) / (fder * (Math.pow(fder, 2) - fval * fder2) + fder3 * Math.pow(fval, 2) / 6));
    if (Math.abs(p - p0) < rtol * Math.abs(p0) + atol) return p;
    p0 = p;
  }
  throw new Error('Failed to converge');
};
function multiSolver(_x5, _x6, _x7, _x8, _x9, _x10) {
  return _multiSolver.apply(this, arguments);
}
function _multiSolver() {
  _multiSolver = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(mu, r1, r2, tof, vi1, vi2) {
    var progradeOptions,
      lowpathOptions,
      minDeltaV,
      bestSolutionV1,
      bestSolutionV2,
      _iterator,
      _step,
      prograde,
      _iterator2,
      _step2,
      low_path,
      _yield$solver,
      _yield$solver2,
      vf1,
      vf2,
      deltaV,
      _args2 = arguments;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          progradeOptions = _args2.length > 6 && _args2[6] !== undefined ? _args2[6] : [true, false];
          lowpathOptions = _args2.length > 7 && _args2[7] !== undefined ? _args2[7] : [true];
          minDeltaV = null;
          _iterator = _createForOfIteratorHelper(progradeOptions);
          _context2.prev = 4;
          _iterator.s();
        case 6:
          if ((_step = _iterator.n()).done) {
            _context2.next = 39;
            break;
          }
          prograde = _step.value;
          _iterator2 = _createForOfIteratorHelper(lowpathOptions);
          _context2.prev = 9;
          _iterator2.s();
        case 11:
          if ((_step2 = _iterator2.n()).done) {
            _context2.next = 29;
            break;
          }
          low_path = _step2.value;
          _context2.prev = 13;
          _context2.next = 16;
          return solver(mu, r1, r2, tof, 0, prograde, low_path);
        case 16:
          _yield$solver = _context2.sent;
          _yield$solver2 = _slicedToArray(_yield$solver, 2);
          vf1 = _yield$solver2[0];
          vf2 = _yield$solver2[1];
          deltaV = math.norm(math.subtract(vi1, vf1)) + math.norm(math.subtract(vi2, vf2));
          if (minDeltaV === null || deltaV < minDeltaV) {
            minDeltaV = deltaV;
            bestSolutionV1 = vf1;
            bestSolutionV2 = vf2;
          }
          _context2.next = 27;
          break;
        case 24:
          _context2.prev = 24;
          _context2.t0 = _context2["catch"](13);
          console.warn(_context2.t0);
        case 27:
          _context2.next = 11;
          break;
        case 29:
          _context2.next = 34;
          break;
        case 31:
          _context2.prev = 31;
          _context2.t1 = _context2["catch"](9);
          _iterator2.e(_context2.t1);
        case 34:
          _context2.prev = 34;
          _iterator2.f();
          return _context2.finish(34);
        case 37:
          _context2.next = 6;
          break;
        case 39:
          _context2.next = 44;
          break;
        case 41:
          _context2.prev = 41;
          _context2.t2 = _context2["catch"](4);
          _iterator.e(_context2.t2);
        case 44:
          _context2.prev = 44;
          _iterator.f();
          return _context2.finish(44);
        case 47:
          return _context2.abrupt("return", {
            v1: bestSolutionV1,
            v2: bestSolutionV2,
            deltaV: minDeltaV
          });
        case 48:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[4, 41, 44, 47], [9, 31, 34, 37], [13, 24]]);
  }));
  return _multiSolver.apply(this, arguments);
}
var lambert = {
  solver: solver,
  multiSolver: multiSolver
};
var farnocchia_rv = function farnocchia_rv(mu, r0, v0, tof) {
  var _rv2coe = rv2coe(mu, r0, v0),
    p = _rv2coe.p,
    ecc = _rv2coe.ecc,
    inc = _rv2coe.inc,
    raan = _rv2coe.raan,
    argp = _rv2coe.argp,
    nu0 = _rv2coe.nu;
  var nu = farnocchia_coe(mu, p, ecc, inc, raan, argp, nu0, tof);
  return coe2rv(mu, p, ecc, inc, raan, argp, nu);
};
var farnocchia_coe = function farnocchia_coe(mu, p, ecc, inc, raan, argp, nu, tof) {
  var q = p / (1 + ecc);
  var delta_t0 = delta_t_from_nu(nu, ecc, mu, q);
  var delta_t = delta_t0 + tof;
  return nu_from_delta_t(delta_t, ecc, mu, q);
};
var delta_t_from_nu = function delta_t_from_nu(nu, ecc) {
  var mu = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var q = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var delta = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-2;
  if (ecc < 0) throw new Error('ecc must be in [0, ∞)');
  if (nu >= Math.PI || nu < -Math.PI) throw new Error('nu must be in [-pi, pi)');
  var M, n;
  if (ecc < 1 - delta) {
    var E = nu_to_E(nu, ecc);
    M = E_to_M(E, ecc);
    n = Math.sqrt(mu * Math.pow(1 - ecc, 3) / Math.pow(q, 3));
  } else if (ecc < 1) {
    var _E = nu_to_E(nu, ecc);
    if (delta <= 1 - ecc * Math.cos(_E)) {
      M = E_to_M(_E, ecc);
      n = Math.sqrt(mu * Math.pow(1 - ecc, 3) / Math.pow(q, 3));
    } else {
      var D = nu_to_D(nu);
      M = D_to_M_near_parabolic(D, ecc);
      n = Math.sqrt(mu / (2 * Math.pow(q, 3)));
    }
  } else if (ecc == 1) {
    var _D = nu_to_D(nu);
    M = D_to_M(_D);
    n = Math.sqrt(mu / (2 * Math.pow(q, 3)));
  } else if (1 + ecc * Math.cos(nu) < 0) {
    return NaN;
  } else if (ecc <= 1 + delta) {
    var F = nu_to_F(nu, ecc);
    if (delta <= ecc * Math.cosh(F) - 1) {
      M = F_to_M(F, ecc);
      n = Math.sqrt(mu * Math.pow(ecc - 1, 3) / Math.pow(q, 3));
    } else {
      var _D2 = nu_to_D(nu);
      M = D_to_M_near_parabolic(_D2, ecc);
      n = Math.sqrt(mu / (2 * Math.pow(q, 3)));
    }
  } else {
    var _F = nu_to_F(nu, ecc);
    M = F_to_M(_F, ecc);
    n = Math.sqrt(mu * Math.pow(ecc - 1, 3) / Math.pow(q, 3));
  }
  return M / n;
};
var nu_from_delta_t = function nu_from_delta_t(delta_t, ecc) {
  var mu = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var q = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var delta = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-2;
  var nu;
  if (ecc < 1 - delta) {
    var n = Math.sqrt(mu * Math.pow(1 - ecc, 3) / Math.pow(q, 3));
    var M = n * delta_t;
    var E = M_to_E(modulo(M + Math.PI, 2 * Math.PI) - Math.PI, ecc);
    nu = E_to_nu(E, ecc);
  } else if (ecc < 1) {
    var E_delta = Math.acos((1 - delta) / ecc);
    var _n2 = Math.sqrt(mu * Math.pow(1 - ecc, 3) / Math.pow(q, 3));
    var _M = _n2 * delta_t;
    if (E_to_M(E_delta, ecc) <= Math.abs(_M)) {
      var _E2 = M_to_E(modulo(_M + Math.PI, 2 * Math.PI) - Math.PI, ecc);
      nu = E_to_nu(_E2, ecc);
    } else {
      var _n3 = Math.sqrt(mu / (2 * Math.pow(q, 3)));
      var _M2 = _n3 * delta_t;
      var D = M_to_D_near_parabolic(_M2, ecc);
      nu = D_to_nu(D);
    }
  } else if (ecc == 1) {
    var _n4 = Math.sqrt(mu / (2 * Math.pow(q, 3)));
    var _M3 = _n4 * delta_t;
    var _D3 = M_to_D(_M3);
    nu = D_to_nu(_D3);
  } else if (ecc <= 1 + delta) {
    var F_delta = Math.acosh((1 + delta) / ecc);
    var _n5 = Math.sqrt(mu * Math.pow(ecc - 1, 3) / Math.pow(q, 3));
    var _M4 = _n5 * delta_t;
    if (F_to_M(F_delta, ecc) <= Math.abs(_M4)) {
      var F = M_to_F(_M4, ecc);
      nu = F_to_nu(F, ecc);
    } else {
      var _n6 = Math.sqrt(mu / (2 * Math.pow(q, 3)));
      var _M5 = _n6 * delta_t;
      var _D4 = M_to_D_near_parabolic(_M5, ecc);
      nu = D_to_nu(_D4);
    }
  } else {
    var _n7 = Math.sqrt(mu * Math.pow(ecc - 1, 3) / Math.pow(q, 3));
    var _M6 = _n7 * delta_t;
    var _F2 = M_to_F(_M6, ecc);
    nu = F_to_nu(_F2, ecc);
  }
  return nu;
};
var propagation = {
  delta_t_from_nu: delta_t_from_nu,
  nu_from_delta_t: nu_from_delta_t,
  farnocchia_coe: farnocchia_coe,
  farnocchia_rv: farnocchia_rv
};
var Orbit = /*#__PURE__*/function () {
  function Orbit(mu, p, ecc, inc, raan, argp, nu) {
    var epoch = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    _classCallCheck(this, Orbit);
    this.mu = mu;
    this.p = p;
    this.ecc = ecc;
    this.inc = inc;
    this.raan = raan;
    this.argp = argp;
    this.nu = nu;
    this.epoch = epoch;
  }
  _createClass(Orbit, [{
    key: "a",
    get: function get() {
      return this.p / (1 - Math.pow(this.ecc, 2));
    }
  }, {
    key: "coe",
    get: function get() {
      return {
        p: this.p,
        ecc: this.ecc,
        inc: this.inc,
        raan: this.raan,
        argp: this.argp,
        nu: this.nu
      };
    }
  }, {
    key: "period",
    get: function get() {
      return 2 * Math.PI * Math.sqrt(Math.pow(Math.abs(this.a), 3) / this.mu);
    }
  }, {
    key: "radius",
    get: function get() {
      return this.p / (1 + this.ecc * Math.cos(this.nu));
    }
  }, {
    key: "rv",
    get: function get() {
      var _coe2rv = coe2rv(this.mu, this.p, this.ecc, this.inc, this.raan, this.argp, this.nu),
        _coe2rv2 = _slicedToArray(_coe2rv, 2),
        r = _coe2rv2[0],
        v = _coe2rv2[1];
      return {
        r: r,
        v: v
      };
    }
  }, {
    key: "propagateFor",
    value: function propagateFor(tof) {
      this.nu = farnocchia_coe(this.mu, this.p, this.ecc, this.inc, this.raan, this.argp, this.nu, tof);
      this.epoch += tof;
    }
  }, {
    key: "propagateTo",
    value: function propagateTo(epoch) {
      var tof = epoch - this.epoch;
      this.propagateFor(tof);
    }
  }, {
    key: "sampleAtEpoch",
    value: function sampleAtEpoch(epoch) {
      var tof = epoch - this.epoch;
      var nu = farnocchia_coe(this.mu, this.p, this.ecc, this.inc, this.raan, this.argp, this.nu, tof);
      return this.sampleAtAngle(nu);
    }
  }, {
    key: "sampleAtAngle",
    value: function sampleAtAngle(nu) {
      var _coe2rv3 = coe2rv(this.mu, this.p, this.ecc, this.inc, this.raan, this.argp, nu),
        _coe2rv4 = _slicedToArray(_coe2rv3, 2),
        r = _coe2rv4[0],
        v = _coe2rv4[1];
      return {
        r: r,
        v: v
      };
    }
  }, {
    key: "ephem",
    value: function ephem() {
      var _this = this;
      var samples = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
      var tof = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (!tof && this.ecc >= 1) throw new Error('tof must be specified for non elliptical orbits');
      if (!tof) tof = this.period;
      if (!start) start = this.epoch;
      var dt = tof / samples;
      var times = Array.from({
        length: samples
      }, function (_, i) {
        return start + i * dt;
      });
      return times.map(function (t) {
        return _this.sampleAtEpoch(t);
      });
    }
  }], [{
    key: "fromStateVectors",
    value: function fromStateVectors(mu, r, v) {
      var epoch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var _rv2coe2 = rv2coe(mu, r, v),
        p = _rv2coe2.p,
        ecc = _rv2coe2.ecc,
        inc = _rv2coe2.inc,
        raan = _rv2coe2.raan,
        argp = _rv2coe2.argp,
        nu = _rv2coe2.nu;
      return new Orbit(mu, p, ecc, inc, raan, argp, nu, epoch);
    }
  }, {
    key: "fromClassicElements",
    value: function fromClassicElements(mu, p, ecc, inc, raan, argp, nu) {
      var epoch = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      return new Orbit(mu, p, ecc, inc, raan, argp, nu, epoch);
    }
  }]);
  return Orbit;
}();
export { Orbit, angles, constants, elements, lambert, propagation };
//# sourceMappingURL=index.js.map
